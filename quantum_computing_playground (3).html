<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Computing Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #2d1b4e 100%);
            color: #fff;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 40px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 3em;
            background: linear-gradient(45deg, #00f2fe, #4facfe, #b17cf7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            animation: glow 3s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(0, 242, 254, 0.5)); }
            50% { filter: drop-shadow(0 0 40px rgba(79, 172, 254, 0.8)); }
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(45deg, #00f2fe, #4facfe);
            border-color: #fff;
            box-shadow: 0 0 20px rgba(0, 242, 254, 0.5);
        }

        .content {
            display: none;
        }

        .content.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .simulation-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        canvas {
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            display: block;
            margin: 20px auto;
            box-shadow: 0 0 30px rgba(0, 242, 254, 0.3);
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        button {
            padding: 12px 25px;
            background: linear-gradient(45deg, #00f2fe, #4facfe);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 242, 254, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 242, 254, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .info-card {
            background: linear-gradient(135deg, rgba(0, 242, 254, 0.1), rgba(177, 124, 247, 0.1));
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        .info-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 242, 254, 0.3);
        }

        .info-card h3 {
            color: #00f2fe;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .qubit-state {
            display: inline-block;
            padding: 5px 15px;
            margin: 5px;
            background: rgba(0, 242, 254, 0.2);
            border-radius: 20px;
            border: 1px solid #00f2fe;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            height: 8px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(45deg, #00f2fe, #4facfe);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(45deg, #00f2fe, #4facfe);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.5);
            border: none;
        }

        .gate-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .gate-btn {
            padding: 15px;
            background: rgba(177, 124, 247, 0.3);
            border: 2px solid #b17cf7;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            color: #fff;
        }

        .gate-btn:hover {
            background: rgba(177, 124, 247, 0.5);
            transform: scale(1.05);
        }

        .circuit-display {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            min-height: 100px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
        }

        .measurement-result {
            font-size: 2em;
            text-align: center;
            padding: 20px;
            background: linear-gradient(45deg, rgba(0, 242, 254, 0.2), rgba(177, 124, 247, 0.2));
            border-radius: 15px;
            margin: 20px 0;
            min-height: 60px;
        }

        .probability-bar {
            width: 100%;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
        }

        .probability-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f2fe, #4facfe);
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        label {
            display: block;
            margin: 10px 0;
            font-weight: 500;
        }

        h2 {
            color: #00f2fe;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>⚛️ Quantum Computing Playground</h1>
            <p>Interactive Simulations & Visualizations</p>
        </header>

        <div class="tabs">
            <div class="tab active" data-tab="qubit">Qubit Basics</div>
            <div class="tab" data-tab="superposition">Superposition</div>
            <div class="tab" data-tab="bloch">Bloch Sphere</div>
            <div class="tab" data-tab="gates">Quantum Gates</div>
            <div class="tab" data-tab="entanglement">Entanglement</div>
            <div class="tab" data-tab="decoherence">Decoherence</div>
            <div class="tab" data-tab="error">Error Correction</div>
        </div>

        <!-- QUBIT BASICS TAB -->
        <div id="qubit" class="content active">
            <div class="simulation-box">
                <h2>Classical Bit vs Quantum Bit</h2>
                <canvas id="bitCanvas" width="800" height="400"></canvas>
                <div class="controls">
                    <button id="toggleBitBtn">Toggle Classical Bit</button>
                    <button id="createSuperBtn">Create Superposition</button>
                    <button id="measureQubitBtn">Measure Qubit</button>
                </div>
                <div class="info-grid">
                    <div class="info-card">
                        <h3>Classical Bit</h3>
                        <p>A classical bit can only be in one state at a time:</p>
                        <div class="qubit-state">0 (OFF)</div>
                        <div class="qubit-state">1 (ON)</div>
                    </div>
                    <div class="info-card">
                        <h3>Quantum Bit (Qubit)</h3>
                        <p>A qubit can exist in superposition:</p>
                        <div class="qubit-state">α|0⟩ + β|1⟩</div>
                        <p style="margin-top: 10px;">Where |α|² + |β|² = 1</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- SUPERPOSITION TAB -->
        <div id="superposition" class="content">
            <div class="simulation-box">
                <h2>Quantum Superposition Visualization</h2>
                <canvas id="superpositionCanvas" width="800" height="400"></canvas>
                <div class="controls">
                    <label>Alpha (|0⟩): <span id="alphaValue">0.71</span></label>
                    <input type="range" id="alphaSlider" min="0" max="100" value="71">
                    <label>Probability |0⟩: <span id="prob0">50%</span> | Probability |1⟩: <span id="prob1">50%</span></label>
                </div>
                <div class="probability-bar">
                    <div class="probability-fill" id="probBar" style="width: 50%">50%</div>
                </div>
                <button id="measureSuperBtn">Measure & Collapse</button>
                <div id="measurementOutput" class="measurement-result"></div>
            </div>
        </div>

        <!-- BLOCH SPHERE TAB -->
        <div id="bloch" class="content">
            <div class="simulation-box">
                <h2>Bloch Sphere - Qubit State Visualization</h2>
                <canvas id="blochCanvas" width="600" height="600"></canvas>
                <div class="controls">
                    <label>Theta (θ): <span id="thetaValue">90°</span></label>
                    <input type="range" id="thetaSlider" min="0" max="180" value="90">
                    <label>Phi (φ): <span id="phiValue">0°</span></label>
                    <input type="range" id="phiSlider" min="0" max="360" value="0">
                </div>
                <div class="info-card">
                    <h3>Current State</h3>
                    <p id="blochState">|ψ⟩ = |0⟩</p>
                    <p>The Bloch sphere represents all possible pure states of a qubit in 3D space.</p>
                </div>
            </div>
        </div>

        <!-- QUANTUM GATES TAB -->
        <div id="gates" class="content">
            <div class="simulation-box">
                <h2>Quantum Gates Circuit Builder</h2>
                <div class="gate-selector">
                    <button class="gate-btn" data-gate="H">H<br>(Hadamard)</button>
                    <button class="gate-btn" data-gate="X">X<br>(Pauli-X)</button>
                    <button class="gate-btn" data-gate="Y">Y<br>(Pauli-Y)</button>
                    <button class="gate-btn" data-gate="Z">Z<br>(Pauli-Z)</button>
                    <button class="gate-btn" data-gate="T">T<br>(π/8 Gate)</button>
                    <button class="gate-btn" data-gate="S">S<br>(Phase)</button>
                </div>
                <div class="circuit-display" id="circuitDisplay">
                    <p style="text-align: center; opacity: 0.5;">Click gates above to build your circuit</p>
                </div>
                <canvas id="gateCanvas" width="800" height="300"></canvas>
                <div class="controls">
                    <button id="runCircuitBtn">Run Circuit</button>
                    <button id="clearCircuitBtn">Clear Circuit</button>
                </div>
                <div id="gateResult" class="measurement-result"></div>
            </div>
        </div>

        <!-- ENTANGLEMENT TAB -->
        <div id="entanglement" class="content">
            <div class="simulation-box">
                <h2>Quantum Entanglement Simulator</h2>
                <canvas id="entanglementCanvas" width="800" height="400"></canvas>
                <div class="controls">
                    <button id="createBellBtn">Create Bell State (|Φ⁺⟩)</button>
                    <button id="measureQ1Btn">Measure Qubit 1</button>
                    <button id="measureQ2Btn">Measure Qubit 2</button>
                    <button id="resetEntBtn">Reset</button>
                </div>
                <div class="info-grid">
                    <div class="info-card">
                        <h3>Qubit 1 State</h3>
                        <p id="qubit1State">|ψ₁⟩ = |0⟩</p>
                    </div>
                    <div class="info-card">
                        <h3>Qubit 2 State</h3>
                        <p id="qubit2State">|ψ₂⟩ = |0⟩</p>
                    </div>
                    <div class="info-card">
                        <h3>Entanglement</h3>
                        <p id="entanglementInfo">Not Entangled</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- DECOHERENCE TAB -->
        <div id="decoherence" class="content">
            <div class="simulation-box">
                <h2>Quantum Decoherence Simulation</h2>
                <canvas id="decoherenceCanvas" width="800" height="400"></canvas>
                <div class="controls">
                    <button id="startDecoBtn">Start Decoherence</button>
                    <button id="pauseDecoBtn">Pause</button>
                    <button id="resetDecoBtn">Reset</button>
                    <label>Noise Level: <span id="noiseLevel">Medium</span></label>
                    <input type="range" id="noiseSlider" min="1" max="10" value="5">
                </div>
                <div class="info-card">
                    <h3>What is Decoherence?</h3>
                    <p>Decoherence is the loss of quantum coherence - when a quantum system loses its quantum properties and behaves classically due to interaction with the environment.</p>
                </div>
            </div>
        </div>

        <!-- ERROR CORRECTION TAB -->
        <div id="error" class="content">
            <div class="simulation-box">
                <h2>Quantum Error Correction</h2>
                <canvas id="errorCanvas" width="800" height="400"></canvas>
                <div class="controls">
                    <button id="encodeBtn">Encode Qubit (3-Bit Code)</button>
                    <button id="introduceErrBtn">Introduce Random Error</button>
                    <button id="correctErrBtn">Detect & Correct Error</button>
                    <button id="resetErrBtn">Reset</button>
                </div>
                <div class="info-grid">
                    <div class="info-card">
                        <h3>Classical Error Correction</h3>
                        <p>Uses redundancy: 0 → 000, 1 → 111</p>
                        <p>Simple majority voting</p>
                    </div>
                    <div class="info-card">
                        <h3>Quantum Error Correction</h3>
                        <p>Cannot clone quantum states (No-Cloning Theorem)</p>
                        <p>Uses entanglement and syndrome measurement</p>
                    </div>
                    <div class="info-card">
                        <h3>Status</h3>
                        <p id="errorStatus">Ready</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        const state = {
            classicalBit: 0,
            qubit: { alpha: Math.SQRT1_2, beta: Math.SQRT1_2 },
            isMeasured: false,
            circuit: [],
            entangled: false,
            qubit1Measured: false,
            qubit2Measured: false,
            qubit1Value: -1,
            qubit2Value: -1,
            decoherenceTime: 0,
            decoherenceAnimation: null,
            entanglementAnimation: null,
            errorState: { encoded: false, error: false, corrected: false, errorBit: -1 }
        };

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabName = this.getAttribute('data-tab');
                
                document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                
                document.getElementById(tabName).classList.add('active');
                this.classList.add('active');
                
                setTimeout(() => {
                    if (tabName === 'qubit') drawBitComparison();
                    if (tabName === 'superposition') updateSuperposition();
                    if (tabName === 'bloch') updateBlochSphere();
                    if (tabName === 'gates') drawCircuit();
                    if (tabName === 'entanglement') drawEntanglement();
                    if (tabName === 'decoherence') drawDecoherence();
                    if (tabName === 'error') drawErrorCorrection();
                }, 100);
            });
        });

        // ===== QUBIT BASICS =====
        function drawBitComparison() {
            const canvas = document.getElementById('bitCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 800, 400);
            
            // Classical Bit
            ctx.fillStyle = '#00f2fe';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('Classical Bit', 100, 50);
            
            ctx.fillStyle = state.classicalBit === 0 ? '#4facfe' : '#333';
            ctx.fillRect(80, 100, 100, 100);
            ctx.fillStyle = '#fff';
            ctx.font = '40px Arial';
            ctx.fillText('0', 115, 165);
            
            ctx.fillStyle = state.classicalBit === 1 ? '#4facfe' : '#333';
            ctx.fillRect(200, 100, 100, 100);
            ctx.fillStyle = '#fff';
            ctx.fillText('1', 235, 165);
            
            // Quantum Bit
            ctx.fillStyle = '#b17cf7';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('Quantum Bit (Qubit)', 500, 50);
            
            if (!state.isMeasured) {
                ctx.save();
                ctx.globalAlpha = state.qubit.alpha * state.qubit.alpha;
                ctx.fillStyle = '#00f2fe';
                ctx.fillRect(480, 100, 100, 100);
                ctx.fillStyle = '#fff';
                ctx.font = '40px Arial';
                ctx.fillText('0', 515, 165);
                ctx.restore();
                
                ctx.save();
                ctx.globalAlpha = state.qubit.beta * state.qubit.beta;
                ctx.fillStyle = '#b17cf7';
                ctx.fillRect(600, 100, 100, 100);
                ctx.fillStyle = '#fff';
                ctx.fillText('1', 635, 165);
                ctx.restore();
                
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.fillText('Superposition!', 520, 240);
            } else {
                const measured = Math.random() < state.qubit.alpha * state.qubit.alpha ? 0 : 1;
                ctx.fillStyle = measured === 0 ? '#00f2fe' : '#b17cf7';
                ctx.fillRect(540, 100, 100, 100);
                ctx.fillStyle = '#fff';
                ctx.font = '40px Arial';
                ctx.fillText(measured, 575, 165);
                ctx.font = '16px Arial';
                ctx.fillText('Collapsed to |' + measured + '⟩', 530, 240);
            }
        }

        document.getElementById('toggleBitBtn').addEventListener('click', () => {
            state.classicalBit = 1 - state.classicalBit;
            drawBitComparison();
        });

        document.getElementById('createSuperBtn').addEventListener('click', () => {
            state.qubit = { alpha: Math.SQRT1_2, beta: Math.SQRT1_2 };
            state.isMeasured = false;
            drawBitComparison();
        });

        document.getElementById('measureQubitBtn').addEventListener('click', () => {
            state.isMeasured = true;
            drawBitComparison();
        });

        // ===== SUPERPOSITION =====
        function updateSuperposition() {
            const canvas = document.getElementById('superpositionCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const alpha = document.getElementById('alphaSlider').value / 100;
            const beta = Math.sqrt(1 - alpha * alpha);
            
            document.getElementById('alphaValue').textContent = alpha.toFixed(2);
            const prob0 = (alpha * alpha * 100).toFixed(1);
            const prob1 = (beta * beta * 100).toFixed(1);
            document.getElementById('prob0').textContent = prob0 + '%';
            document.getElementById('prob1').textContent = prob1 + '%';
            document.getElementById('probBar').style.width = prob0 + '%';
            document.getElementById('probBar').textContent = prob0 + '%';
            
            ctx.clearRect(0, 0, 800, 400);
            
            ctx.strokeStyle = '#00f2fe';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let x = 0; x < 800; x++) {
                const y = 200 + Math.sin(x * 0.02) * alpha * 100;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            ctx.strokeStyle = '#b17cf7';
            ctx.beginPath();
            for (let x = 0; x < 800; x++) {
                const y = 200 + Math.cos(x * 0.02) * beta * 100;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            ctx.fillStyle = '#00f2fe';
            ctx.font = '16px Arial';
            ctx.fillText('|0⟩ amplitude', 20, 30);
            ctx.fillStyle = '#b17cf7';
            ctx.fillText('|1⟩ amplitude', 20, 60);
        }

        document.getElementById('alphaSlider').addEventListener('input', updateSuperposition);

        document.getElementById('measureSuperBtn').addEventListener('click', () => {
            const alpha = document.getElementById('alphaSlider').value / 100;
            const result = Math.random() < (alpha * alpha) ? 0 : 1;
            document.getElementById('measurementOutput').textContent = `Measured: |${result}⟩`;
        });

        // ===== BLOCH SPHERE =====
        function updateBlochSphere() {
            const canvas = document.getElementById('blochCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const theta = document.getElementById('thetaSlider').value * Math.PI / 180;
            const phi = document.getElementById('phiSlider').value * Math.PI / 180;
            
            document.getElementById('thetaValue').textContent = Math.round(theta * 180 / Math.PI) + '°';
            document.getElementById('phiValue').textContent = Math.round(phi * 180 / Math.PI) + '°';
            
            ctx.clearRect(0, 0, 600, 600);
            
            const cx = 300, cy = 300, r = 150;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx - r - 20, cy);
            ctx.lineTo(cx + r + 20, cy);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx, cy - r - 20);
            ctx.lineTo(cx, cy + r + 20);
            ctx.stroke();
            
            ctx.fillStyle = '#00f2fe';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('|0⟩', cx, cy - r - 30);
            ctx.fillText('|1⟩', cx, cy + r + 45);
            ctx.fillText('X', cx + r + 30, cy + 5);
            ctx.fillText('Y', cx - r - 30, cy + 5);
            
            const x = r * Math.sin(theta) * Math.cos(phi);
            const z = r * Math.sin(theta) * Math.sin(phi);
            const y = -r * Math.cos(theta);
            
            ctx.strokeStyle = '#b17cf7';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + x, cy + y);
            ctx.stroke();
            
            ctx.fillStyle = '#b17cf7';
            ctx.beginPath();
            ctx.arc(cx + x, cy + y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            const alpha = Math.cos(theta / 2);
            const beta = Math.sin(theta / 2);
            document.getElementById('blochState').textContent = 
                `|ψ⟩ = ${alpha.toFixed(3)}|0⟩ + ${beta.toFixed(3)}e^(i${phi.toFixed(2)})|1⟩`;
            
            ctx.textAlign = 'left';
        }

        document.getElementById('thetaSlider').addEventListener('input', updateBlochSphere);
        document.getElementById('phiSlider').addEventListener('input', updateBlochSphere);

        // ===== QUANTUM GATES =====
        function drawCircuit() {
            const canvas = document.getElementById('gateCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 800, 300);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 150);
            ctx.lineTo(750, 150);
            ctx.stroke();
            
            ctx.fillStyle = '#fff';
            ctx.font = '18px Arial';
            ctx.fillText('|0⟩', 10, 155);
            
            state.circuit.forEach((gate, i) => {
                const x = 100 + i * 80;
                ctx.fillStyle = 'rgba(177, 124, 247, 0.3)';
                ctx.strokeStyle = '#b17cf7';
                ctx.lineWidth = 3;
                ctx.fillRect(x - 25, 120, 50, 60);
                ctx.strokeRect(x - 25, 120, 50, 60);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(gate, x, 157);
            });
            
            ctx.textAlign = 'left';
        }

        function addGate(gateName) {
            state.circuit.push(gateName);
            const display = document.getElementById('circuitDisplay');
            display.innerHTML = '<div style="display: flex; gap: 10px; align-items: center; justify-content: center; flex-wrap: wrap;">';
            display.innerHTML += '<span style="font-weight: bold;">|0⟩ →</span>';
            state.circuit.forEach((gate, i) => {
                display.innerHTML += `<span style="padding: 10px 20px; background: rgba(177, 124, 247, 0.5); border: 2px solid #b17cf7; border-radius: 8px; font-weight: bold;">${gate}</span>`;
                if (i < state.circuit.length - 1) display.innerHTML += '<span>→</span>';
            });
            display.innerHTML += '<span>→ ?</span></div>';
            drawCircuit();
        }

        function applyGate(qstate, gate) {
            const { alpha, beta } = qstate;
            let newAlpha, newBeta;
            
            switch(gate) {
                case 'H':
                    newAlpha = (alpha + beta) / Math.SQRT2;
                    newBeta = (alpha - beta) / Math.SQRT2;
                    break;
                case 'X':
                    newAlpha = beta;
                    newBeta = alpha;
                    break;
                case 'Y':
                    newAlpha = -beta;
                    newBeta = alpha;
                    break;
                case 'Z':
                    newAlpha = alpha;
                    newBeta = -beta;
                    break;
                case 'T':
                case 'S':
                    newAlpha = alpha;
                    newBeta = beta;
                    break;
                default:
                    return qstate;
            }
            
            return { alpha: newAlpha, beta: newBeta };
        }

        document.querySelectorAll('.gate-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                addGate(this.getAttribute('data-gate'));
            });
        });

        document.getElementById('runCircuitBtn').addEventListener('click', () => {
            if (state.circuit.length === 0) {
                document.getElementById('gateResult').textContent = 'Add gates to the circuit first!';
                return;
            }
            
            let qstate = { alpha: 1, beta: 0 };
            
            state.circuit.forEach(gate => {
                qstate = applyGate(qstate, gate);
            });
            
            const prob0 = (qstate.alpha * qstate.alpha * 100).toFixed(1);
            const prob1 = (qstate.beta * qstate.beta * 100).toFixed(1);
            
            document.getElementById('gateResult').innerHTML = 
                `Final State: ${qstate.alpha.toFixed(3)}|0⟩ + ${qstate.beta.toFixed(3)}|1⟩<br>` +
                `P(|0⟩) = ${prob0}% | P(|1⟩) = ${prob1}%`;
        });

        document.getElementById('clearCircuitBtn').addEventListener('click', () => {
            state.circuit = [];
            document.getElementById('circuitDisplay').innerHTML = 
                '<p style="text-align: center; opacity: 0.5;">Click gates above to build your circuit</p>';
            document.getElementById('gateResult').textContent = '';
            drawCircuit();
        });

        // ===== ENTANGLEMENT =====
        function drawEntanglement() {
            const canvas = document.getElementById('entanglementCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 800, 400);
            
            const q1x = 250, q2x = 550, qy = 200;
            
            let q1Color = '#666';
            let q1Text = '?';
            if (state.qubit1Measured) {
                q1Color = state.qubit1Value === 0 ? '#00f2fe' : '#b17cf7';
                q1Text = state.qubit1Value.toString();
            } else if (state.entangled) {
                q1Color = 'rgba(0, 242, 254, 0.5)';
            }
            
            ctx.fillStyle = q1Color;
            ctx.beginPath();
            ctx.arc(q1x, qy, 60, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Q1', q1x, qy - 80);
            ctx.font = '40px Arial';
            ctx.fillText(q1Text, q1x, qy + 15);
            
            let q2Color = '#666';
            let q2Text = '?';
            if (state.qubit2Measured) {
                q2Color = state.qubit2Value === 0 ? '#00f2fe' : '#b17cf7';
                q2Text = state.qubit2Value.toString();
            } else if (state.entangled) {
                q2Color = 'rgba(177, 124, 247, 0.5)';
            }
            
            ctx.fillStyle = q2Color;
            ctx.beginPath();
            ctx.arc(q2x, qy, 60, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 30px Arial';
            ctx.fillText('Q2', q2x, qy - 80);
            ctx.font = '40px Arial';
            ctx.fillText(q2Text, q2x, qy + 15);
            
            if (state.entangled && !state.qubit1Measured && !state.qubit2Measured) {
                ctx.strokeStyle = '#b17cf7';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(q1x + 60, qy);
                ctx.lineTo(q2x - 60, qy);
                ctx.stroke();
                ctx.setLineDash([]);
                
                const time = Date.now() / 1000;
                for (let i = 0; i < 5; i++) {
                    const progress = (time + i * 0.2) % 1;
                    const x = q1x + 60 + (q2x - q1x - 120) * progress;
                    const offset = Math.sin(time * 3 + i * Math.PI / 2) * 10;
                    ctx.fillStyle = '#b17cf7';
                    ctx.beginPath();
                    ctx.arc(x, qy + offset, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.textAlign = 'left';
        }

        document.getElementById('createBellBtn').addEventListener('click', () => {
            state.entangled = true;
            state.qubit1Measured = false;
            state.qubit2Measured = false;
            state.qubit1Value = -1;
            state.qubit2Value = -1;
            
            document.getElementById('qubit1State').textContent = '|ψ₁⟩ = (|0⟩ + |1⟩)/√2';
            document.getElementById('qubit2State').textContent = '|ψ₂⟩ = (|0⟩ + |1⟩)/√2';
            document.getElementById('entanglementInfo').textContent = 'Entangled! |Φ⁺⟩ = (|00⟩ + |11⟩)/√2';
            
            if (state.entanglementAnimation) clearInterval(state.entanglementAnimation);
            state.entanglementAnimation = setInterval(() => {
                if (state.entangled && !state.qubit1Measured && !state.qubit2Measured) {
                    drawEntanglement();
                }
            }, 50);
        });

        document.getElementById('measureQ1Btn').addEventListener('click', () => {
            if (!state.entangled || state.qubit1Measured) return;
            
            state.qubit1Value = Math.random() < 0.5 ? 0 : 1;
            state.qubit2Value = state.qubit1Value;
            state.qubit1Measured = true;
            
            document.getElementById('qubit1State').textContent = `|ψ₁⟩ = |${state.qubit1Value}⟩ (Measured)`;
            document.getElementById('qubit2State').textContent = `|ψ₂⟩ = |${state.qubit2Value}⟩ (Collapsed)`;
            drawEntanglement();
        });

        document.getElementById('measureQ2Btn').addEventListener('click', () => {
            if (!state.entangled || state.qubit2Measured) return;
            
            state.qubit2Value = Math.random() < 0.5 ? 0 : 1;
            state.qubit1Value = state.qubit2Value;
            state.qubit2Measured = true;
            
            document.getElementById('qubit1State').textContent = `|ψ₁⟩ = |${state.qubit1Value}⟩ (Collapsed)`;
            document.getElementById('qubit2State').textContent = `|ψ₂⟩ = |${state.qubit2Value}⟩ (Measured)`;
            drawEntanglement();
        });

        document.getElementById('resetEntBtn').addEventListener('click', () => {
            if (state.entanglementAnimation) {
                clearInterval(state.entanglementAnimation);
                state.entanglementAnimation = null;
            }
            
            state.entangled = false;
            state.qubit1Measured = false;
            state.qubit2Measured = false;
            state.qubit1Value = -1;
            state.qubit2Value = -1;
            
            document.getElementById('qubit1State').textContent = '|ψ₁⟩ = |0⟩';
            document.getElementById('qubit2State').textContent = '|ψ₂⟩ = |0⟩';
            document.getElementById('entanglementInfo').textContent = 'Not Entangled';
            drawEntanglement();
        });

        // ===== DECOHERENCE =====
        function drawDecoherence() {
            const canvas = document.getElementById('decoherenceCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 800, 400);
            
            const coherence = Math.exp(-state.decoherenceTime / 100);
            
            ctx.strokeStyle = `rgba(0, 242, 254, ${coherence})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            for (let x = 0; x < 800; x++) {
                const y = 200 + Math.sin(x * 0.05 + state.decoherenceTime * 0.1) * 80 * coherence;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            const noiseLevel = document.getElementById('noiseSlider').value / 10;
            ctx.fillStyle = `rgba(255, 100, 100, ${1 - coherence})`;
            for (let i = 0; i < 100 * noiseLevel; i++) {
                const x = Math.random() * 800;
                const y = 100 + Math.random() * 200;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.fillText(`Coherence: ${(coherence * 100).toFixed(1)}%`, 20, 40);
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 60, 200, 20);
            const r = Math.floor(255 * (1 - coherence));
            const g = Math.floor(255 * coherence);
            ctx.fillStyle = `rgb(${r}, ${g}, 100)`;
            ctx.fillRect(20, 60, 200 * coherence, 20);
        }

        document.getElementById('startDecoBtn').addEventListener('click', () => {
            if (state.decoherenceAnimation) return;
            state.decoherenceAnimation = setInterval(() => {
                state.decoherenceTime += 1;
                drawDecoherence();
                if (state.decoherenceTime >= 500) {
                    clearInterval(state.decoherenceAnimation);
                    state.decoherenceAnimation = null;
                }
            }, 50);
        });

        document.getElementById('pauseDecoBtn').addEventListener('click', () => {
            if (state.decoherenceAnimation) {
                clearInterval(state.decoherenceAnimation);
                state.decoherenceAnimation = null;
            }
        });

        document.getElementById('resetDecoBtn').addEventListener('click', () => {
            if (state.decoherenceAnimation) {
                clearInterval(state.decoherenceAnimation);
                state.decoherenceAnimation = null;
            }
            state.decoherenceTime = 0;
            drawDecoherence();
        });

        document.getElementById('noiseSlider').addEventListener('input', function() {
            const level = this.value;
            const labels = ['Very Low', 'Low', 'Medium-Low', 'Medium', 'Medium-High', 'High', 'Very High', 'Extreme', 'Maximum', 'Critical'];
            document.getElementById('noiseLevel').textContent = labels[level - 1];
            drawDecoherence();
        });

        // ===== ERROR CORRECTION =====
        function drawErrorCorrection() {
            const canvas = document.getElementById('errorCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 800, 400);
            
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.font = '18px Arial';
            
            if (!state.errorState.encoded) {
                ctx.fillStyle = '#00f2fe';
                ctx.beginPath();
                ctx.arc(400, 200, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 30px Arial';
                ctx.fillText('|ψ⟩', 400, 210);
                ctx.font = '16px Arial';
                ctx.fillText('Original Qubit', 400, 280);
            } else {
                for (let i = 0; i < 3; i++) {
                    const x = 250 + i * 150;
                    let color = '#00f2fe';
                    let label = '|ψ⟩';
                    
                    if (state.errorState.error && i === state.errorState.errorBit && !state.errorState.corrected) {
                        color = '#ff4444';
                        label = '✗';
                    } else if (state.errorState.corrected && i === state.errorState.errorBit) {
                        color = '#44ff44';
                        label = '✓';
                    }
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, 200, 40, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText(label, x, 208);
                    ctx.font = '14px Arial';
                    ctx.fillText(`Qubit ${i + 1}`, x, 260);
                }
                
                ctx.strokeStyle = 'rgba(177, 124, 247, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(290, 200);
                ctx.lineTo(510, 200);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.textAlign = 'left';
        }

        document.getElementById('encodeBtn').addEventListener('click', () => {
            state.errorState = { encoded: true, error: false, corrected: false, errorBit: -1 };
            document.getElementById('errorStatus').textContent = 'Qubit encoded using 3-qubit repetition code';
            drawErrorCorrection();
        });

        document.getElementById('introduceErrBtn').addEventListener('click', () => {
            if (!state.errorState.encoded) {
                document.getElementById('errorStatus').textContent = 'Please encode the qubit first!';
                return;
            }
            state.errorState.error = true;
            state.errorState.errorBit = Math.floor(Math.random() * 3);
            state.errorState.corrected = false;
            document.getElementById('errorStatus').textContent = `Error introduced in Qubit ${state.errorState.errorBit + 1}!`;
            drawErrorCorrection();
        });

        document.getElementById('correctErrBtn').addEventListener('click', () => {
            if (!state.errorState.error) {
                document.getElementById('errorStatus').textContent = 'No error to correct!';
                return;
            }
            state.errorState.corrected = true;
            document.getElementById('errorStatus').textContent = `Error detected and corrected in Qubit ${state.errorState.errorBit + 1}!`;
            drawErrorCorrection();
            
            setTimeout(() => {
                state.errorState.error = false;
                state.errorState.corrected = false;
                drawErrorCorrection();
                document.getElementById('errorStatus').textContent = 'Error corrected successfully!';
            }, 2000);
        });

        document.getElementById('resetErrBtn').addEventListener('click', () => {
            state.errorState = { encoded: false, error: false, corrected: false, errorBit: -1 };
            document.getElementById('errorStatus').textContent = 'Ready';
            drawErrorCorrection();
        });

        // Initialize
        window.addEventListener('load', () => {
            drawBitComparison();
        });
    </script>
</body>
</html>